This file list the C++ Grammar.

=========================
Inheritance & Derivative
=========================

The ChildClass Access Rights Status:
-------------------------------------------------------
BaseClass	Inherited Method from Base to Child
AccessRights	public		protected	private
-------------------------------------------------------
public		public		protedted	private
protected	protected	protected	private
private		-		-		-
-------------------------------------------------------

How to restore class member's access rights in BaseClass?
1.using
2.BaseClass::Member


Overload(重载)
在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，
但参数或返回值不同（包括类型、顺序不同），即函数重载。
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
1、参数类型、个数、顺序至少有一个不相同。   
2、不能重载只有返回值不同的方法名。 
3、存在于父类和子类、同类中。 
Override(覆盖)是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
Overwrite/Redefinition(重写)：是指派生类的函数屏蔽了与其同名的基类函数，
规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无
virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有
virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

-------------------
operator
-------------------
运算符重载就是赋予已有的运算符多重含义。通过重新定义运算符，
使它能够用于特定类的对象执行特定的功能，这便增强了C++语言的扩充能力。

不能重载的运算符只有五个，它们是：成员运算符“.”、指针运算符“*”、
作用域运算符“：：”、“sizeof”、条件运算符“？：”。 
运算符重载形式有两种，重载为类的成员函数和重载为类的友元函数。
当运算符重载为类的成员函数时，函数的参数个数比原来的操作个数要少一个；
当重载为类的友元函数时，参数个数与原操作数个数相同。原因是重载为类的
成员函数时，如果某个对象使用重载了的成员函数，自身的数据可以直接访问，
就不需要再放在参数表中进行传递，少了的操作数就是该对象本身。而重载为
友元函数时，友元函数对某个对象的数据进行操作，就必须通过该对象的名称
来进行，因此使用到的参数都要进行传递，操作数的个数就不会有变化。 
运算符重载的主要优点就是允许改变使用于系统内部的运算符的操作方式，
以适应用户自定义类型的类似运算。 

对于双目运算符B，如果要重载B为类的成员函数，使之能够实现表达式
oprd1 B oprd2,其中oprd1为类A的对象，则应当把B重载为A类的成员函数，
该函数只有一个形参，形参的类型是oprd2所属的类型。经过重载后，表达式
oprd1 B oprd2 就相当于函数调用oprd1.operator B(oprd2). 
对于前置单目运算符U，如“-”（负号）等，如果要重载U为类的成员函数，
用来实现表达式U oprd，其中oprd为A类的对象，则U应当重载为A类的成员函数，
函数没有形参。经过重载之后，表达式U oprd相当于函数调用oprd.operator U(). 
对于后置运算符“++”和“--”，如果要将它们重载为类的成员函数，用来实现表达式
oprd++或oprd--，其中oprd为A类的对象，那么运算符就应当重载为A类的成员函数，
这时函数要带有一个整型形参。重载之后，表达式oprd++和oprd—就想当于函数调用
oprd.operator++(0)和oprd.operator—(0); 

4. 编译程序如何选用哪一个运算符函数:
运算符重载实际是一个函数，所以运算符的重载实际上是函数的重载。
编译程序对运算符重载的选择，遵循着函数重载的选择原则。
当遇到不很明显的运算时，编译程序将去寻找参数相匹配的运算符函数。
 
5. 重载运算符有哪些限制:
(1)不可臆造新的运算符。必须把重载运算符限制在C++语言中已有的
运算符范围内的允许重载的运算符之中。
(2)重载运算符坚持4个“不能改变”。
·不能改变运算符操作数的个数；
·不能改变运算符原有的优先级；
·不能改变运算符原有的结合性；
·不能改变运算符原有的语法结构。


-------------------
copy constructor 
-------------------
For a class X, if the constructor function is one of below, and there
are not any other parameters or there are default values for other
parameters, then this function is a copy constructor.
1) X&
2) const X&
3) volatile X&
4) const volatile X&

X::X(const X&);
X::X(X&,int=1);
X::X(X&,int a=1,int b=2);
